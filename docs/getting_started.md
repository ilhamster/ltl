# Getting Started

To learn more about linear temporal logic and how the `ltl` library implements
it, visit [ltl](ltl.md).

This library provides many ways to build and use linear temporal logic
expressions.  Regardless of how the library is used, any use requires two
things:

* An input type implementing `Token`;

* At least one *matcher*: a terminal `Operation` that consumes one or more
Tokens and returns a resolved `Environment`.

`ltl` includes several implementations for both `Token` and compatible terminal
`Operation`s:

* `examples/signals` includes a basic `Token` type, and corresponding matcher,
  which are suitable for applications involving multiple concurrent binary
  signals, such as logic circuits.

* `examples/runetoken` includes a `Token` type for `rune`s.
  `examples/stringmatcher` provides a matcher consuming `RuneToken`s, as well as
  string-binding `BindingEnvironment`s.

More information about implementing customer `Token`, `Operator`, and
`Environment` types, including new matchers, is available in `pkg/ltl/ltl.go`.

## Programmatic LTL

The `Operator`s defined in `operators/operators.go` may be directly invoked,
along with suitable matchers.  Examples of this usage are provided in
`pkg/operators/operators_test.go`

For example, suppose that `A`, `B`, and `C` are matchers; then a sequence of
`ABC` may be specified by

`ltl.Then(A, ltl.Then(B, C))`

or

`Sequence(A, B, C)`

## Parsed LTL expressions

The parser defined in `pkg/parser` provides a means of parsing LTL expressions.
This parser's grammar is specified in `pkg/parser/parser.y`, and which is built
using `goyacc` by invoking `scripts/build_parser.sh`.

An expression is parsed into an `Operator` using `parser.ParseLTL`.  This
method takes a `parser.Lexer`, which is in turn generated by `parser.NewLexer`.
`NewLexer` accepts a mapping of strings to parser tokens --
`parser.DefaultTokens` provides a reasonable default.  It also accepts a
*matcher generator* function (`func(string) (ltl.Operator, error)`), which
parses strings and returns matchers -- this parser considers strings enclosed in
matching square brackets, `[]`, to be matchers, and provides them to its
generator function.  `stringmatcher.Generator` provides one such generator
function.  Finally, `NewLexer` accepts a `bufio.Reader` that reads the
expression to parse.

With `DefaultTokens` and `stringmatcher.Generator`, if matchers `A`, `B`, and
`C` match the literal strings `a`, `b`, and `c` respectively, the same
expression as described above is returned from parsing

`[a] THEN [b] THEN [c]`

`stringmatcher.Generator` can also produce [binding and referencing)(binding.md)
matchers. A variable `a` is bound by:

`$a<-`

which binds the current `RuneToken` to variable `a`.  `a` is referenced by

`$a`

So, matching three of the same token in a row is expressed as

`[$a<-] THEN [$a] THEN [$a]`

This syntax is used throughout this documentation.

## `ltltool`

`tools/ltltool.go` provides a way to quickly start experimenting with LTL
queries.  It uses `pkg/parser` to parse expressions, with matchers provided by
`examples/stringmatcher`.  `ltltool` provides tools for debugging LTL
expressions and testing them against input streams.